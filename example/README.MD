
	#1 ФП 
	Функциональное П. это программирование в виде запроса результата
	пример из Лиспа:
	print(+ 2, 3,(* 4, 5 (- 7,8))) 

	напишем класс Funs, который будет содержать набрр каких-н методов,
	например метод для сложения и для вычитания. 
	особенность в том,что он должен принимать варарг

	class Funs{
		public static int sum(int ...args){
			int sum=0;
			for (int i:agrs)
				sum+=args[i];
		}
		
		public static int men(int ...agrs){
			int res=args[0];
			for(i=1;i<agrs.length(); i++){
				res-=args[i];
			}
			return res;
		}

	попробуем объедтнить эти действия в одно
	для уточнения действия будем передавать char ch

	public static action (char ch, int ...args)
	и делать условие : если ch = '+', если ch = '-'

	выглядит ужасно. 

	#2 Лямбды
	благо в Java 8 стало можно передавать поведение
	Выглядит это так, что если у нас есть интерфейс с одним методом
	(который нафывается функциональный интерфейс)
	то мы можем передать поведение

	заведем интерфейс 

		Action{
			int act(int x, int y)
		}

	..и будем принимать этот интерфейс вместо char
	в теле метода избавимся от if-else конструкций, сделав одиин универсальный for, 
	перебирая значения варарга, и применяя к каждому метод act() интерфейса Action{}
	(мы пока не знаем, какой конкретно будет действие, 
	потому что передадим его)

		for(...) res=action.act(res, args[i]);

	как этим пользоваться? в Java 8 появились лямбда-выражения, выглядит так:

		action((x, y)->x-y, 10, 2, action((x,y)->x+y), 3, 3) 
		
	Итак, мы унифицировали действия, и теперь можем выполнять даже разные нестандартные действия
	правда, пока только с целыми числами.

	#3 Работа с произвольным типом данных
	а что если захотим работать со строками? Или вообще с любым типом данных?
	Вспоминаем Дженерики. Т к если у нас кокой-то неизвестный тип, значит этито работа с обобщениями

	Action<T>{
		T act(T x, T y);
	} 

	public static <T> T action(Action<T> action, T ...args){
		T  res = args[0];
		...
	}

	теперь, например, можем работать со строками
		action((x,y)->x+y, "aa", "bb")
	или придумать что-то поинтереснее

#4 Листы
вообще, даже название языка Лисп расшифровывается как Лист Процессор
т е мы должны стремиться работать со списками вместо прямого перечисления аргументов и варарга
Добавим Листы.
минимальные переделки в Funs - agrs.get(i), args.size(), принимаем List<T> вместо варарга
в Main создадим lst = List.of("aa", "bb") и передадим его в action 

#5
Теперь надо подумать, а какие самые частые действия над Листами?
- мин/макс-сумма-количество определенных элементов и т.д.,
- отсортировать (ее пока не трогаем),
- отфильтровать, 
- преобразовать все элементы опредобразом (МАП)

 рассмотрим три вида действий над списками:
  - агрегация(reduce) - в результате получить одно значение - мин/макс, сумму, количество и т.д
  - Фильтр ()
  - Мап (выполнить действия к каждому эл-ту,исоздать из них новый список)
  
#6 Результат другого типа
Первый вроде уже есть, просто переименуем Action в Reduce.
Правда, еще нужно добавить возможность получать редультат другого типа, нежели исходные данные

interface Action<T,R>{
	R act (T x, T y);

<T,R> R reduce (Action<T,R> action, List<T> args){
	R res = action.act(x.get(0), x.get(1))
	for...
	
нет. может так?
	R act (R x, T y)
тоже плохо
заглянем в библиотеку java.util.Function<T,R>

проблема в том, что Action должен быть каким-то сложным.
В том, что надо склыдывать начальныйтип скаким-то конечным
и изначально этот тип R надо откуда-то получить
поэтому мы будем принимать некий начальный R в reduce,  
чтобы знать,к какому типу в конечном итоге приводиться

interface Reduction<T,R>{
	R reduce(R x, T y);

public class Funs{
	public static<T,R> R reduce(R startVal, List<T> args, Reduction<T,R> reduction){
		R res = startVal;
		...
		поскольку startVal берем снаружи, цикл начинаем с args.get(0)
	}
}	

---Main - добавили стартовое значение пустую строку, и поменяли местами аргументы 
	reduce("", lst, (x,y)->x+y) 

#7 filter
теперь займемся Фильтром
он возвращает лист того же типа,

Нужен другой интерфейс. 
Фильтр это условие, значит метод функ интерфейса будет возвращать Boolean

interface Usloviye{
	Boolean ()
}
и в Funs напишем новый метод 
	static <T> List<T>filter (List<T> args, Usloviye<T> usloviye)
который внутри себя создает пустой Лист, 
в цикле проверяет соответствует ли элемент условию, и добавляет в этот новый список
новый список нужен, чтобы не портить старый

проверим в Main 
	reduce("", filter(lst, x->x.length()>3), (x,y)->x+y)
работает!

#8 Map
Заведём интерфейс Changer, принимающий один элемент типа T и возвращающий R
и напишем метод 

static<T,R> List<R> map(List<T> args, Changer<T,R> changer)
который сохздает пустой список, 
в цикле к каждому элементу аргументов применяет действие changer.change(arg),
добавляя результат в свежесозданный список

проверим:
	reduce("", map(filter(lst, x->x.length()>3), x->x.length()), (x,y)->x+y)
возвращает "56", т е он сложил 5 и 6 как строки  

однако если мы передадим в reduce в качестве стартового значения 0
	reduce(0, map(filter(lst, x->x.length()>3), x->x.length()), (x,y)->x+y)
то получим результат сложения чисел 5 и 6, то есть 11 :) 